# iot-cpp-2025-plus
IoT 개발자 C++ 보충 수업

## 1일차
- 사용자 정의 자료형 : 구조체, 클래스
- 오버로딩/오버라이딩
    - 오버로딩 (순서가 달라도 다른 메서드!)
    - 오버라이딩  
- 객체지향언어
    - 클래스 안에 들어가는 함수 : 메서드
- 임시 객체

#### 함수
1. 함수의 선언 (Declaration): 함수의 존재를 컴파일러에게 알려줌
   - 형태: 반환타입 함수이름(매개변수타입);
   - 예: void func(); int func2(int);

2. 함수의 정의 (Definition): 함수의 실제 동작을 구현
   - 형태: 반환타입 함수이름(매개변수) { 함수 내용 }
   - 예: void func() { printf("Hello\n"); }

3. 함수의 호출 (Call): 정의된 함수를 실행
   - 형태: 함수이름(실인자);
   - 예: func(); func1('a'); int result = func2(10);

4. 매개변수 (Parameter):
   - 형식매개변수: 함수 정의에서 사용되는 변수 (예: char arg, int n)
   - 실인자: 함수 호출 시 실제로 전달되는 값 (예: ch, num)

5. 반환값 (Return Value):
   - void: 반환값 없음
   - int, char 등: 해당 타입의 값을 반환
   - return 문으로 값을 반환

#### 데이터 타입
1. 부호 비트 (Sign Bit):
   - char: 최상위 비트가 부호 비트 (0=양수, 1=음수)
   - unsigned char: 모든 비트가 데이터 비트

2. 2의 보수 (Two's Complement):
   - 음수를 표현하는 방법
   - 모든 비트를 뒤집고 1을 더함
   - 예: -1 = ~0 + 1 = 1111 1111

3. 오버플로우 (Overflow):
   - 저장 가능한 범위를 초과하는 값
   - 상위 비트가 잘림
   - 예: 0x11f → 0x1f (상위 1비트 제거)

4. 비트 시프트 연산:
   - 좌측 시프트 (<<): 왼쪽으로 이동, 오른쪽은 0으로 채움 (×2 효과)
   - 우측 시프트 (>>): 
     * unsigned: 논리적 시프트 (왼쪽을 0으로 채움)
     * signed: 산술적 시프트 (왼쪽을 부호 비트로 채움)

5. 논리적 vs 산술적 시프트:
   - 논리적: 빈 자리를 항상 0으로 채움
   - 산술적: 빈 자리를 부호 비트로 채움 (부호 확장)

6. 형식 지정자:
   - %#x: 16진수로 출력 (0x 접두사 포함)
   - %d: 부호 있는 10진수로 출력
   - %u: 부호 없는 10진수로 출력

7. 메모리 관점:
   - 같은 비트 패턴이라도 해석 방식에 따라 다른 값
   - 시프트 연산 결과도 부호 여부에 따라 다르게 해석됨

## 2일차
### 메모리 구조 개요
   높은 주소 (0xFFFFFFFF)
   ┌─────────────────────┐
   │    스택 (Stack)      │ ← 지역변수, 매개변수, 함수 호출 정보
   │        ↓            │   (높은 주소에서 낮은 주소로 성장)
   ├─────────────────────┤
   │       여유 공간      │
   ├─────────────────────┤
   │        ↑            │
   │     힙 (Heap)       │ ← 동적 할당 메모리 (malloc, new)
   ├─────────────────────┤   (낮은 주소에서 높은 주소로 성장)
   │ BSS 세그먼트         │ ← 초기화되지 않은 전역/static 변수
   ├─────────────────────┤
   │ 데이터 세그먼트       │ ← 초기화된 전역/static 변수
   ├─────────────────────┤
   │ 코드 세그먼트         │ ← 실행 코드, 함수들
   └─────────────────────┘
   낮은 주소 (0x00000000)
    

1. 메모리 세그먼트 구조:
   - 코드 세그먼트: 실행 코드, 함수들 (읽기 전용)
   - 데이터 세그먼트: 초기화된 전역/static 변수
   - BSS 세그먼트: 초기화되지 않은 전역/static 변수
   - 힙: 동적 할당 메모리 (malloc, new)
   - 스택: 지역 변수, 함수 호출 정보

2. 스택 (Stack)의 특징:
   - LIFO (Last In First Out) 구조
   - 함수 호출 시 새로운 프레임 생성
   - 함수 종료 시 프레임 제거
   - 일반적으로 높은 주소에서 낮은 주소로 성장
   - 크기 제한 있음 (보통 1-8MB)
   - 자동 메모리 관리 (변수 스코프 벗어나면 자동 해제)

3. 힙 (Heap)의 특징:
   - 동적 메모리 할당 영역
   - 일반적으로 낮은 주소에서 높은 주소로 성장
   - 프로그래머가 직접 관리 (malloc/free, new/delete)
   - 크기 제한이 스택보다 훨씬 큼
   - 메모리 누수 위험 있음
   - 조각화(fragmentation) 발생 가능

4. 스택 vs 힙 비교:
   ┌─────────────────┬──────────────────┬──────────────────┐
   │     특성        │      스택        │       힙         │
   ├─────────────────┼──────────────────┼──────────────────┤
   │   할당 속도     │      빠름        │      느림        │
   │   메모리 관리   │      자동        │      수동        │
   │   크기 제한     │      작음        │      큼          │
   │   조각화        │      없음        │      있음        │
   │   접근 속도     │      빠름        │    상대적 느림   │
   │   메모리 누수   │      없음        │    위험 있음     │
   └─────────────────┴──────────────────┴──────────────────┘

5. 스택 프레임 (Stack Frame):
   - 각 함수 호출마다 생성되는 스택 영역
   - 지역 변수, 매개변수, 복귀 주소 등 포함
   - 함수 종료 시 자동으로 해제됨

6. 변수 저장 위치:
   - 지역 변수: 스택
   - 전역 변수: 데이터 세그먼트
   - static 변수: 데이터 세그먼트 (지역/전역 구분 없이)
   - 동적 할당: 힙

7. 주소 패턴:
   - 코드 세그먼트: 가장 낮은 주소
   - 데이터 세그먼트: 중간 주소
   - 힙: 중간-높은 주소 (위쪽으로 성장)
   - 스택: 가장 높은 주소 (아래쪽으로 성장)

8. 메모리 문제들:
   - 스택 오버플로우: 너무 깊은 재귀, 큰 지역 변수
   - 메모리 누수: 힙 메모리 해제 안 함
   - 댕글링 포인터: 해제된 메모리 접근
   - 힙 조각화: 반복적 할당/해제로 인한 메모리 파편화

9. 좋은 프로그래밍 관습:
   - malloc/new 후 반드시 free/delete
   - 해제 후 포인터를 NULL로 설정
   - 큰 데이터는 힙에 할당
   - 임시 데이터는 스택 활용


### 가비지 컬렉션(Garbage Collection)
- 더 이상 사용하지 않는 메모리를 자동으로 회수하는 메모리 관리 기법
-

**참조 변수에는 객체의 주소가 저장되어 있음!!**
- 참조 변수에 null 입력 -> 아무것도 가리키고 있지 X